<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>WW1 Dogfight – Single Player vs Bots (Improved Demo)</title>
        <style>
            html,
            body {
                margin: 0;
                padding: 0;
                height: 100%;
                overflow: hidden;
                background: #0b0f16;
                font-family:
                    system-ui,
                    Segoe UI,
                    Roboto,
                    Inter,
                    Arial;
            }
            #hud {
                position: fixed;
                top: 12px;
                left: 12px;
                color: #e6ecf1;
                background: rgba(0, 0, 0, 0.35);
                padding: 10px 12px;
                border-radius: 10px;
                line-height: 1.25;
                font-size: 14px;
            }
            #hud .row {
                display: flex;
                gap: 10px;
                align-items: center;
            }
            #msg {
                position: fixed;
                top: 12px;
                right: 12px;
                color: #e6ecf1;
                background: rgba(0, 0, 0, 0.35);
                padding: 10px 12px;
                border-radius: 10px;
                font-size: 14px;
                max-width: 40ch;
            }
            #capture {
                position: fixed;
                bottom: 12px;
                left: 50%;
                transform: translateX(-50%);
                color: #e6ecf1;
                background: rgba(0, 0, 0, 0.35);
                padding: 10px 12px;
                border-radius: 10px;
                font-size: 14px;
            }
            #crosshair {
                position: fixed;
                left: 50%;
                top: 50%;
                width: 24px;
                height: 24px;
                margin-left: -12px;
                margin-top: -12px;
                border: 2px solid rgba(255, 255, 255, 0.7);
                border-radius: 50%;
                box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.25) inset;
            }
            #crosshair:after {
                content: "";
                position: absolute;
                left: 50%;
                top: 50%;
                width: 2px;
                height: 2px;
                background: #fff;
                margin-left: -1px;
                margin-top: -1px;
                border-radius: 50%;
            }
            .testbar {
                position: fixed;
                bottom: 12px;
                right: 12px;
                background: rgba(0, 0, 0, 0.35);
                color: #cfe3ee;
                padding: 10px 12px;
                border-radius: 10px;
                font-size: 12px;
                max-width: 42ch;
                white-space: pre-line;
            }
            .hint {
                position: fixed;
                bottom: 12px;
                left: 12px;
                background: rgba(0, 0, 0, 0.35);
                color: #cfe3ee;
                padding: 10px 12px;
                border-radius: 10px;
                font-size: 12px;
            }
            a {
                color: #9ad1ff;
            }
        </style>
    </head>
    <body>
        <div id="hud"></div>
        <div id="msg">
            Click the game to lock mouse. W/S throttle · ←/→ yaw · ↑/↓ pitch · Q/E roll · Space fire · Land on runway
            (slow & level) to repair & reload
        </div>
        <div id="capture">Runway: <span id="capPct">0%</span> (hold to capture)</div>
        <div id="crosshair"></div>
        <div class="testbar" id="testbar">Running self-tests…</div>
        <div class="hint">Mouse controls: move to aim (yaw/pitch), Q/E to bank. ESC to unlock.</div>

        <script type="module">
            async function loadThree() {
                const cdns = [
                    "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
                    "https://unpkg.com/three@0.161.0/build/three.module.js",
                    "https://esm.sh/three@0.161.0",
                ];
                let lastErr;
                for (const url of cdns) {
                    try {
                        return await import(url);
                    } catch (e) {
                        lastErr = e;
                    }
                }
                throw lastErr || new Error("Failed to load three.module.js from all CDNs");
            }

            const testbar = document.getElementById("testbar");
            function logTest(msg, ok = true) {
                // IMPORTANT: use \n, not a literal newline inside quotes
                testbar.textContent =
                    (testbar.textContent ? testbar.textContent + "\n" : "") + (ok ? "✅ " : "❌ ") + msg;
            }

            let THREE;
            try {
                THREE = await loadThree();
                logTest("Loaded Three.js module");
            } catch (e) {
                logTest("Could not load Three.js. " + e.message, false);
                alert("Three.js failed to load. Error: " + e.message);
                throw e;
            }

            // ====== Scene & Renderer ======
            const scene = new THREE.Scene();
            // Gradient sky base
            const skyTop = new THREE.Color(0x6aa0d8),
                skyBottom = new THREE.Color(0x102030);
            scene.background = skyBottom.clone();

            const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2500);

            const hemi = new THREE.HemisphereLight(0xcde6ff, 0x223344, 0.9);
            scene.add(hemi);
            const sun = new THREE.DirectionalLight(0xfff7e0, 1.0);
            sun.position.set(200, 300, 150);
            scene.add(sun);

            // ====== Terrain ======
            const groundGeo = new THREE.PlaneGeometry(5000, 5000, 64, 64);
            groundGeo.rotateX(-Math.PI / 2);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x2a4b33, roughness: 1, metalness: 0 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.receiveShadow = true;
            scene.add(ground);

            const runwayLen = 700,
                runwayWid = 70;
            const runwayGeo = new THREE.PlaneGeometry(runwayLen, runwayWid);
            runwayGeo.rotateX(-Math.PI / 2);
            const runwayMat = new THREE.MeshStandardMaterial({ color: 0x2b2b2b, roughness: 0.8 });
            const runway = new THREE.Mesh(runwayGeo, runwayMat);
            runway.position.set(0, 0.01, 0);
            scene.add(runway);

            const markMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            for (let i = -runwayLen / 2 + 40; i < runwayLen / 2; i += 60) {
                const m = new THREE.Mesh(new THREE.PlaneGeometry(10, 4), markMat);
                m.rotateX(-Math.PI / 2);
                m.position.set(i, 0.02, 0);
                scene.add(m);
            }

            // Props (trees)
            const treeMat = new THREE.MeshStandardMaterial({ color: 0x3f4d3f, roughness: 0.9 });
            for (let i = 0; i < 120; i++) {
                const tree = new THREE.Mesh(
                    new THREE.ConeGeometry(6 + Math.random() * 10, 28 + Math.random() * 30, 7),
                    treeMat,
                );
                const angle = Math.random() * Math.PI * 2;
                const radius = 700 + Math.random() * 1800;
                tree.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
                scene.add(tree);
            }

            // ====== Helpers ======
            function forwardOf(obj) {
                return new THREE.Vector3(1, 0, 0).applyQuaternion(obj.quaternion);
            }
            function bankAngleZ(obj) {
                return -obj.rotation.z;
            } // roll right positive
            function loadFactorFromBank(phi) {
                const c = Math.cos(phi);
                return 1 / Math.max(0.1, c);
            }

            // ====== Plane Factory ======
            function makePlane(color = 0xbcc6cc) {
                const group = new THREE.Group();
                const fus = new THREE.Mesh(
                    new THREE.CapsuleGeometry(3, 8, 6, 12),
                    new THREE.MeshStandardMaterial({ color, roughness: 0.7 }),
                );
                fus.rotation.z = Math.PI / 2;
                group.add(fus);
                const wingGeo = new THREE.BoxGeometry(18, 0.4, 2.2);
                const wingMat = new THREE.MeshStandardMaterial({ color: 0x9aa7ad, roughness: 0.8 });
                const wingTop = new THREE.Mesh(wingGeo, wingMat);
                wingTop.position.set(0, 1.8, 0);
                const wingBot = new THREE.Mesh(wingGeo, wingMat);
                wingBot.position.set(0, -0.8, 0);
                group.add(wingTop, wingBot);
                const tail = new THREE.Mesh(new THREE.BoxGeometry(4, 0.3, 1.2), wingMat);
                tail.position.set(-5.5, 0.6, 0);
                group.add(tail);
                const rudder = new THREE.Mesh(new THREE.BoxGeometry(0.3, 2, 1.0), wingMat);
                rudder.position.set(-6.2, 1.2, 0);
                group.add(rudder);
                const prop = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 2, 12),
                    new THREE.MeshStandardMaterial({ color: 0x333, metalness: 0.2, roughness: 0.6 }),
                );
                prop.rotation.z = Math.PI / 2;
                prop.position.set(6.2, 0, 0);
                group.add(prop);
                group.userData.prop = prop;
                group.traverse((o) => {
                    o.castShadow = true;
                    o.receiveShadow = true;
                });
                return group;
            }

            // ====== Player & State ======
            const player = makePlane(0xcfe3ee);
            scene.add(player);
            player.position.set(-200, 40, -200);

            const state = {
                throttle: 0.55,
                maxThrust: 40,
                dragCoef: 0.012,
                liftCoef: 0.085,
                baseStall: 12,
                vel: new THREE.Vector3(),
                hp: 100,
                ammo: 400,
                jam: 0, // gun jam cooldown
                score: 0,
                landed: false,
            };

            // ====== Input (Keyboard + Mouse pointer lock) ======
            const keys = {};
            addEventListener("keydown", (e) => {
                keys[e.code] = true;
            });
            addEventListener("keyup", (e) => {
                keys[e.code] = false;
            });

            const canvas = renderer.domElement;
            canvas.addEventListener("click", () => {
                if (document.pointerLockElement !== canvas) canvas.requestPointerLock();
            });

            const mouse = { dx: 0, dy: 0, sens: 0.0016 };
            addEventListener("mousemove", (e) => {
                if (document.pointerLockElement === canvas) {
                    mouse.dx += e.movementX;
                    mouse.dy += e.movementY;
                }
            });

            // ====== Bots ======
            const BOT_COUNT = 8;
            const bots = [];
            for (let i = 0; i < BOT_COUNT; i++) {
                const b = makePlane(0xd37f7f);
                scene.add(b);
                const ang = i * ((Math.PI * 2) / BOT_COUNT);
                b.position.set(Math.cos(ang) * 400 - 200, 60 + Math.random() * 30, Math.sin(ang) * 400);
                b.rotation.y = Math.random() * Math.PI * 2;
                b.userData = {
                    vel: new THREE.Vector3(),
                    throttle: 0.58,
                    hp: 70,
                    thinkCooldown: 0,
                    fireCd: 0,
                    target: player,
                };
                bots.push(b);
            }

            // ====== Projectiles & Particles ======
            const bullets = [];
            const particles = [];
            function spawnBullet(origin, dir, from) {
                // dispersion (minutes of angle approx)
                const spread = from === "player" ? 0.0035 : 0.0055; // radians
                const rand = new THREE.Euler((Math.random() - 0.5) * spread, (Math.random() - 0.5) * spread, 0);
                const dir2 = dir.clone().applyEuler(rand).normalize();
                const geo = new THREE.SphereGeometry(0.09, 6, 6);
                const mat = new THREE.MeshBasicMaterial({ color: from === "player" ? 0xffffff : 0xffd080 });
                const m = new THREE.Mesh(geo, mat);
                m.position.copy(origin);
                m.userData = { vel: dir2.multiplyScalar(185), ttl: 1.1, from };
                scene.add(m);
                bullets.push(m);
            }

            function spawnSmoke(pos, vel, life = 1.2) {
                const geo = new THREE.SphereGeometry(0.4, 6, 6);
                const mat = new THREE.MeshBasicMaterial({ color: 0x555555, transparent: true, opacity: 0.7 });
                const s = new THREE.Mesh(geo, mat);
                s.position.copy(pos);
                s.userData = { vel: vel.clone().add(new THREE.Vector3(0, 0.5, 0)), ttl: life };
                scene.add(s);
                particles.push(s);
            }

            // ====== Runway Capture / Repair ======
            let captureProgress = 0;
            const capSpan = document.getElementById("capPct");
            function inRunwayBounds(pos) {
                return (
                    Math.abs(pos.x - runway.position.x) <= runwayLen / 2 &&
                    Math.abs(pos.z - runway.position.z) <= runwayWid / 2
                );
            }

            function handleLandingRepair(dt) {
                const speed = state.vel.length();
                const onGround = player.position.y <= 1.1;
                const aligned = Math.abs(player.rotation.z) < 0.2 && Math.abs(player.rotation.x) < 0.2;
                const enemiesNearby = bots.some(
                    (b) => b.userData.hp > 0 && b.position.distanceTo(runway.position) < 120,
                );
                if (onGround && speed < 6 && inRunwayBounds(player.position) && aligned) {
                    state.landed = true;
                    state.hp = Math.min(100, state.hp + 25 * dt);
                    if (state.hp >= 100) state.ammo = Math.min(400, state.ammo + 80 * dt);
                    const rate = enemiesNearby ? 6 : 18; // contest slows capture
                    captureProgress = Math.min(100, captureProgress + rate * dt);
                } else {
                    state.landed = false;
                    captureProgress = Math.max(0, captureProgress - 4 * dt);
                }
                capSpan.textContent = captureProgress.toFixed(0) + "%";
            }

            // ====== HUD ======
            const hud = document.getElementById("hud");
            function drawHUD() {
                const spd = state.vel.length();
                const n = loadFactorFromBank(bankAngleZ(player));
                hud.innerHTML =
                    `<div class="row"><b>Spd:</b> ${spd.toFixed(1)} m/s &nbsp; <b>Thr:</b> ${(state.throttle * 100) | 0}% &nbsp; <b>HP:</b> ${state.hp | 0} &nbsp; <b>Ammo:</b> ${state.ammo | 0} &nbsp; <b>Jam:</b> ${state.jam > 0 ? state.jam.toFixed(1) + "s" : "—"} &nbsp; <b>Score:</b> ${state.score}</div>` +
                    `<div class="row"><b>Bots:</b> ${bots.filter((b) => b.userData.hp > 0).length}/${BOT_COUNT} &nbsp; <b>n(load):</b> ${n.toFixed(2)} &nbsp; <b>Capture:</b> ${captureProgress.toFixed(0)}%</div>`;
            }

            // ====== Player Physics & Controls ======
            let fireTimer = 0;
            let respawnTimer = 0.5;
            function updatePlayer(dt) {
                // Throttle
                if (keys["KeyW"]) state.throttle = Math.min(1, state.throttle + 0.45 * dt);
                if (keys["KeyS"]) state.throttle = Math.max(0, state.throttle - 0.45 * dt);

                // Mouse yaw/pitch
                const yawMouse = mouse.dx * mouse.sens;
                const pitchMouse = mouse.dy * mouse.sens;
                mouse.dx = 0;
                mouse.dy = 0;
                const yawIn = (keys["ArrowLeft"] ? -1 : 0) + (keys["ArrowRight"] ? 1 : 0) + yawMouse * 2.0;
                const pitchIn = (keys["ArrowUp"] ? 1 : 0) + (keys["ArrowDown"] ? -1 : 0) + -pitchMouse * 1.8;
                const rollIn = (keys["KeyQ"] ? -1 : 0) + (keys["KeyE"] ? 1 : 0) + yawMouse * 0.6; // auto-bank with yaw

                // Control authority scales with damage
                const controlScale = 0.6 + 0.4 * (state.hp / 100);
                player.rotation.y += THREE.MathUtils.clamp(yawIn, -1, 1) * 1.0 * dt * controlScale;
                player.rotation.z += THREE.MathUtils.clamp(-rollIn, -1, 1) * 2.0 * dt * controlScale;
                player.rotation.x += THREE.MathUtils.clamp(-pitchIn, -1, 1) * 1.3 * dt * controlScale;

                // Aerodynamics
                const fwd = forwardOf(player);
                const thrustScale = 0.6 + 0.4 * (state.hp / 100); // engine damage reduces thrust
                const thrust = fwd.clone().multiplyScalar(state.maxThrust * state.throttle * thrustScale);

                const v = state.vel;
                const drag = v.clone().multiplyScalar(-state.dragCoef * v.length());

                // Lift with load factor from bank angle
                const n = loadFactorFromBank(bankAngleZ(player));
                const up = new THREE.Vector3(0, 1, 0).applyQuaternion(player.quaternion);
                const liftMag = state.liftCoef * Math.max(0, v.length()) * n;
                const lift = up.multiplyScalar(liftMag);

                // Gravity
                const gravity = new THREE.Vector3(0, -9.8, 0);

                v.add(thrust.add(drag).add(lift).add(gravity).multiplyScalar(dt));

                // Stall model: stall threshold increases with sqrt(n)
                const stallV = state.baseStall * Math.sqrt(n);
                if (v.length() < stallV && player.rotation.x < -0.25) {
                    v.y -= (stallV - v.length()) * 1.8 * dt;
                }

                // Ground collision
                player.position.add(v.clone().multiplyScalar(dt));
                if (player.position.y < 0.5) {
                    player.position.y = 0.5;
                    if (v.y < 0) v.y *= -0.2;
                    v.x *= 0.98;
                    v.z *= 0.98;
                }

                // Guns: jam mechanic and ROF
                if (keys["Space"] && state.ammo > 0 && state.jam <= 0) {
                    fireTimer -= dt;
                    if (fireTimer <= 0) {
                        const f = forwardOf(player);
                        const muzzle = player.position
                            .clone()
                            .add(f.clone().multiplyScalar(6.6))
                            .add(new THREE.Vector3(0, 0.3, 0));
                        spawnBullet(muzzle, f, "player");
                        state.ammo -= 1;
                        fireTimer = 0.05; // 20 rps
                        // small chance to jam if overheating
                        if (Math.random() < 0.002) {
                            state.jam = 2.0;
                        }
                    }
                } else {
                    fireTimer = 0;
                }
                if (state.jam > 0) state.jam = Math.max(0, state.jam - dt);

                // Damage feedback: smoke when hurt
                if (state.hp < 40 && Math.random() < 0.2) {
                    const back = player.position.clone().add(fwd.clone().multiplyScalar(-2));
                    spawnSmoke(back, v.clone().multiplyScalar(0.02), 0.8);
                }

                // Respawn
                if (state.hp <= 0) {
                    respawnTimer -= dt;
                    if (respawnTimer <= 0) {
                        state.hp = 100;
                        state.ammo = 400;
                        state.vel.set(0, 0, 0);
                        player.position.set(-200, 40, -200);
                        player.rotation.set(0, Math.random() * Math.PI * 2, 0);
                        respawnTimer = 0.5;
                    }
                }

                // Prop visuals
                if (player.userData.prop) player.userData.prop.rotation.x += (20 + 80 * state.throttle) * dt;
            }

            // ====== Bots ======
            function updateBots(dt) {
                bots.forEach((b) => {
                    const d = b.userData;
                    if (d.hp <= 0) {
                        b.visible = false;
                        return;
                    }
                    b.visible = true;
                    d.thinkCooldown -= dt;
                    d.fireCd -= dt;
                    if (d.thinkCooldown <= 0) {
                        // Steering towards predicted lead point
                        const toP = player.position.clone().sub(b.position);
                        const bulletSpeed = 185;
                        const dist = toP.length();
                        const tLead = dist / bulletSpeed;
                        const leadPos = player.position.clone().add(state.vel.clone().multiplyScalar(tLead));
                        const aimDir = leadPos.sub(b.position).normalize();
                        const desiredYaw = Math.atan2(aimDir.z, aimDir.x);
                        const curYaw = b.rotation.y;
                        const yawDelta = wrapAngle(desiredYaw - curYaw);
                        b.rotation.y += THREE.MathUtils.clamp(yawDelta, -0.8 * dt, 0.8 * dt);
                        const dy = player.position.y - b.position.y;
                        b.rotation.x += THREE.MathUtils.clamp(-dy * 0.002, -0.6 * dt, 0.6 * dt);
                        // keep some bank
                        b.rotation.z += THREE.MathUtils.clamp((Math.random() - 0.5) * 0.8 * dt, -0.8 * dt, 0.8 * dt);
                        d.thinkCooldown = 0.02;
                    }
                    // Energy & thrust
                    const fwd = forwardOf(b);
                    const thrust = fwd.clone().multiplyScalar(36 * d.throttle);
                    d.vel.add(thrust.multiplyScalar(dt));
                    d.vel.add(d.vel.clone().multiplyScalar(-0.012 * d.vel.length() * dt));
                    d.vel.y += -9.8 * dt;
                    b.position.add(d.vel.clone().multiplyScalar(dt));
                    if (b.position.y < 1) {
                        b.position.y = 1;
                        d.vel.y = Math.abs(d.vel.y) * 0.2;
                        d.vel.x *= 0.98;
                        d.vel.z *= 0.98;
                    }

                    // Fire if aligned
                    const toP2 = player.position.clone().sub(b.position);
                    const dist2 = toP2.length();
                    if (dist2 < 380) {
                        const aim = forwardOf(b).normalize();
                        const cos = aim.dot(toP2.normalize());
                        if (cos > 0.985 && d.fireCd <= 0) {
                            const muzzle = b.position.clone().add(aim.clone().multiplyScalar(6.4));
                            spawnBullet(muzzle, aim, "bot");
                            d.fireCd = 0.06;
                        }
                    }

                    // Smoke when damaged
                    if (d.hp < 35 && Math.random() < 0.15) {
                        const back = b.position.clone().add(forwardOf(b).multiplyScalar(-2));
                        spawnSmoke(back, d.vel.clone().multiplyScalar(0.02), 0.8);
                    }
                });
            }

            // ====== Bullets & Collisions ======
            function updateBullets(dt) {
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const b = bullets[i];
                    b.userData.ttl -= dt;
                    if (b.userData.ttl <= 0) {
                        scene.remove(b);
                        bullets.splice(i, 1);
                        continue;
                    }
                    b.position.add(b.userData.vel.clone().multiplyScalar(dt));
                    if (b.userData.from === "player") {
                        for (const t of bots) {
                            if (t.userData.hp > 0 && b.position.distanceTo(t.position) < 2.0) {
                                t.userData.hp -= 20;
                                if (t.userData.hp <= 0) {
                                    state.score += 100;
                                }
                                scene.remove(b);
                                bullets.splice(i, 1);
                                break;
                            }
                        }
                    } else {
                        if (state.hp > 0 && b.position.distanceTo(player.position) < 2.0) {
                            state.hp -= 15;
                            scene.remove(b);
                            bullets.splice(i, 1);
                        }
                    }
                }
            }

            // ====== Particles ======
            function updateParticles(dt) {
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.userData.ttl -= dt;
                    if (p.userData.ttl <= 0) {
                        scene.remove(p);
                        particles.splice(i, 1);
                        continue;
                    }
                    p.material.opacity = Math.max(0, p.userData.ttl / 1.2);
                    p.position.add(p.userData.vel.clone().multiplyScalar(dt));
                    p.scale.multiplyScalar(1 + 0.4 * dt);
                }
            }

            // ====== Camera ======
            function updateCamera(dt) {
                const fwd = forwardOf(player);
                const behind = player.position
                    .clone()
                    .add(fwd.clone().multiplyScalar(-13))
                    .add(new THREE.Vector3(0, 4, 0));
                camera.position.lerp(behind, 1 - Math.pow(0.001, dt));
                const lookAt = player.position.clone().add(fwd.clone().multiplyScalar(10));
                camera.lookAt(lookAt);
            }

            // ====== Loop ======
            let last = performance.now() / 1000;
            function loop() {
                const now = performance.now() / 1000;
                let dt = Math.min(0.033, now - last);
                last = now;
                updatePlayer(dt);
                updateBots(dt);
                updateBullets(dt);
                updateParticles(dt);
                handleLandingRepair(dt);
                updateCamera(dt);
                drawHUD();
                renderer.render(scene, camera);
                requestAnimationFrame(loop);
            }
            loop();

            addEventListener("resize", () => {
                renderer.setSize(innerWidth, innerHeight);
                camera.aspect = innerWidth / innerHeight;
                camera.updateProjectionMatrix();
            });

            // ====== Runtime Self‑tests ======
            try {
                console.assert(THREE != null, "THREE module is present");
                logTest("THREE namespace present");
                const v = new THREE.Vector3(1, 2, 3);
                v.add(new THREE.Vector3(1, 0, -1));
                console.assert(v.x === 2 && v.y === 2 && v.z === 2, "Vector3 add works");
                logTest("Vector math");
                console.assert(typeof forwardOf === "function", "forwardOf exists");
                logTest("Utility present: forwardOf");
                console.assert(typeof inRunwayBounds === "function", "inRunwayBounds exists");
                logTest("Runway helper exists");
                console.assert(
                    !inRunwayBounds(new THREE.Vector3(runwayLen, 0, runwayWid)),
                    "Runway bounds outside false",
                );
                logTest("Runway bounds outside");
                // Load factor tests
                const n0 = loadFactorFromBank(0),
                    n60 = loadFactorFromBank(Math.PI / 3);
                console.assert(Math.abs(n0 - 1) < 1e-6, "n(0)=1");
                console.assert(Math.abs(n60 - 2) < 0.05, "n(60°)≈2");
                logTest("Load factor checks");
                // Stall scaling monotonic
                const s0 = 12 * Math.sqrt(n0),
                    s60 = 12 * Math.sqrt(n60);
                console.assert(s60 > s0, "stall increases with bank");
                logTest("Stall scaling");
                // Renderer & camera exists
                console.assert(renderer instanceof THREE.WebGLRenderer, "renderer ok");
                logTest("Renderer present");
                console.assert(camera instanceof THREE.PerspectiveCamera, "camera ok");
                logTest("Camera present");
                // wrapAngle contract
                const wa = ((a) => {
                    while (a > Math.PI) a -= Math.PI * 2;
                    while (a < -Math.PI) a += Math.PI * 2;
                    return a;
                })(4 * Math.PI);
                console.assert(wa >= -Math.PI && wa <= Math.PI, "wrapAngle range");
                logTest("wrapAngle range");
                logTest("Self-tests passed.");
            } catch (e) {
                logTest("Self-tests failed: " + e.message, false);
            }

            function wrapAngle(a) {
                while (a > Math.PI) a -= Math.PI * 2;
                while (a < -Math.PI) a += Math.PI * 2;
                return a;
            }
        </script>
    </body>
</html>
